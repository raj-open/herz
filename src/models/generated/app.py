# generated by datamodel-codegen:
#   filename:  schema-app.yaml

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Optional, Union

from pydantic import AnyUrl, BaseModel, ConfigDict, Field, RootModel


class RepoInfo(BaseModel):
    """
    Basic infos about repo
    """

    model_config = ConfigDict(
        extra='allow',
        populate_by_name=True,
    )
    name: str
    description: str
    version: str
    homepage: AnyUrl


class MatchingConfig(BaseModel):
    """
    Designates to each data series the name of a special point
    to be used for alignment of the data series.
    These can then be used as a starting points.
    """

    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    pressure: str
    volume: str


class PolyCritCondition(BaseModel):
    """
    A condition to force on fitted polynomial of the form:
    - The `n`-th derivative has `h` critical points.
    """

    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    derivative: int = Field(..., ge=0)
    num_critical: int = Field(..., alias='num-critical', ge=0)


class PolyDerCondition(BaseModel):
    """
    A condition to force on fitted polynomial of the form:

    - The `n`-th derivative at time point `t` must be `0`.
    """

    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    derivative: int = Field(..., ge=0)
    time: float


class TimeInterval(BaseModel):
    """
    Defines end points of a time-interval (`a` to `b`).
    """

    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    a: float
    b: float


class PointPV(BaseModel):
    """
    Structure of a point in the P-V space.
    """

    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    pressure: float
    volume: float


class PointFormat(BaseModel):
    """
    Style settings for plotting special points/lines.

    - `size` - <int> size of marker or width of line.
    - `colour` - <string> colour of marker/line.
        can be either a name or of the form
        `'rgba(<float>,<float>,<float>,<float>)'`, `'hsla(<int>,<float>%,<float>%,<float>)'`, etc.
    - `symbol` - <string> see <https://plotly.com/python/marker-style>.
    - (optional) `text` - <string> symbol for text inside the plot
    - `text-position` - <string> where text is to be positioned,
        Values: 'top|middle|bottom left|center|right'
    """

    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    size: int = Field(
        2,
        description='In the case of marker settings this determines the symbol-size.\nIn the case of line settings this determines the line-width.',
    )
    colour: str = 'black'
    symbol: str = Field(
        'x',
        description='In the case of marker settings this determines the symbol.\nIn the case of line settings this determines the line-style.',
    )
    text: str = None
    text_position: str = Field('top center', alias='text-position')


class FitTrigIntialisation(BaseModel):
    """
    Provides initial estimates for model parameters
    as parseable expressions.
    """

    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    omega: Union[str, int, float] = '2 * math.pi / 2'
    hshift: Union[str, int, float] = 0
    vscale: Union[str, int, float] = 1
    vshift: Union[str, int, float] = 0
    drift: Union[str, int, float] = 0


class FitExpIntialisation(BaseModel):
    """
    Provides initial estimates for model parameters
    as parseable expressions.
    """

    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    beta: Union[str, int, float] = 0
    vshift: Union[str, int, float] = 1
    vscale: Union[str, int, float] = 0


class PairString(RootModel[List[str]]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: List[str] = Field(..., max_length=2, min_length=2)


class EnumCriticalPoints(str, Enum):
    """
    Enumeration of critical point types.
    """

    UNKNOWN = 'UNKNOWN'
    ZERO = 'ZERO'
    MINIMUM = 'MINIMUM'
    MAXIMUM = 'MAXIMUM'
    LOCAL_MINIMUM = 'LOCAL-MINIMUM'
    LOCAL_MAXIMUM = 'LOCAL-MAXIMUM'
    INFLECTION = 'INFLECTION'


class EnumBoundKind(str, Enum):
    """
    Enumeration bound types.
    """

    HSCALE_LOWER_BOUND = 'HSCALE-LOWER-BOUND'
    HSCALE_UPPER_BOUND = 'HSCALE-UPPER-BOUND'
    INVHSCALE_LOWER_BOUND = 'INVHSCALE-LOWER-BOUND'
    INVHSCALE_UPPER_BOUND = 'INVHSCALE-UPPER-BOUND'


class EnumModelKind(str, Enum):
    """
    Enumeration of kinds of models
    """

    DATA = 'DATA'
    POLY_MODEL = 'POLY-MODEL'
    TRIG_MODEL = 'TRIG-MODEL'


class EnumSpecialPointPVKind(str, Enum):
    """
    Enumeration of kinds of special points on P-V curve
    """

    GRADIENT = 'GRADIENT'
    PRESSURE = 'PRESSURE'
    VOLUME = 'VOLUME'


class EnumSolver(str, Enum):
    """
    Enumeration of modi for solver.
    """

    BRUTE_FORCE = 'BRUTE-FORCE'
    GRADIENT = 'GRADIENT'
    HYBRID_GRADIENT = 'HYBRID-GRADIENT'


class AppInfo(RootModel[Any]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Any


class PolyIntCondition(BaseModel):
    """
    A condition to force on fitted polynomial of the form:

    - The integral over the union of the time intervals must be `0`.
    """

    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    times: List[TimeInterval] = Field(..., min_length=1)


class SpecialPointsConfigPV(BaseModel):
    """
    Information associated with the computation of a special point
    on the PV-curve.
    """

    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    name: str = Field(..., description='Name of special point.')
    name_simple: Optional[str] = Field(None, alias='name-simple', description='A table-friendly version of the name.')
    description: Optional[str] = Field(None, description='A table-friendly description of the point.')
    ignore: bool = Field(False, description='Option to suppress plotting.')
    visible: bool = Field(True, description='Point is shown, but deactivated by default.')
    found: bool = Field(False, description='Option to mark whether point successfully computed.')
    kind: EnumSpecialPointPVKind
    value: float = -1
    data: List[PointPV] = []
    format: PointFormat = Field(..., description='Settings for plot marker/line.')


class SpecialPointsSpec(BaseModel):
    """
    A single condition used to defined special point in terms of

    - position relative to other special points,
    - criticality of an n'th derivative

    NOTE: The 'before' / 'after' conditions are defined purely in terms of the peak-to-peak cycle.
    """

    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    derivative: int = Field(0, description="Order of the n'th derivative condition.", ge=0)
    kind: EnumCriticalPoints = Field(..., description="Kind of n'th derivative condition: (local) min/max.")
    reuse: bool = Field(False, description='Whether the recognised point is to be reused for the 2nd round of fitting.')
    strict: bool = Field(
        True,
        description='Whether the point is to occur strictly inside the cycle.\n\nDefault: `true`.\n\nNOTE: Only set to `false` for a time point that is the peak value.',
    )
    after: List[str] = Field(
        ..., description='The currently specified point has to occur after this list of named points.'
    )
    before: List[str] = Field(
        ..., description='The currently specified point has to occur before this list of named points.'
    )


class InterpConfigPoly(BaseModel):
    """
    Settings use to fit polynomial interpolations.
    """

    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    interval: PairString


class Solver(BaseModel):
    """
    Settings for the solver.
    """

    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    n_max: int = Field(..., alias='n-max', ge=0)
    mode: EnumSolver = Field(
        EnumSolver.BRUTE_FORCE, description='Determines the mode in which the fitting algorithm is executed.'
    )
    model: EnumModelKind = Field(
        EnumModelKind.DATA, description='Indicates whether to fit against the data or another model.'
    )
    drift: bool = Field(..., description='Indicates whether to include drift term in model.')


class FitTrigCondition(BaseModel):
    """
    Conditions to define bounds on the frequency.
    """

    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    kind: EnumBoundKind = Field(..., description='Kind of bound.')
    value: str = Field(..., description='Parseable expression for the value of the bound.')


class Solver1(BaseModel):
    """
    Settings for the solver.
    """

    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    n_max: int = Field(..., alias='n-max', description='Maximum number of iterations', ge=0)
    model: EnumModelKind = Field(
        EnumModelKind.DATA, description='Indicates whether to fit against the data or another model.'
    )
    mode: EnumSolver = Field(
        EnumSolver.BRUTE_FORCE, description='Determines the mode in which the fitting algorithm is executed.'
    )


class FitExpCondition(BaseModel):
    """
    Conditions to define bounds on the frequency.
    """

    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    kind: EnumBoundKind = Field(..., description='Kind of bound.')
    value: str = Field(..., description='Parseable expression for the value of the bound.')


class PolynomialConfig(BaseModel):
    """
    Setting on for polynomial fitting for cycles within a time-series.
    """

    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    pressure: List[Union[PolyCritCondition, PolyDerCondition, PolyIntCondition]]
    volume: List[Union[PolyCritCondition, PolyDerCondition, PolyIntCondition]]


class SpecialPointsConfig(BaseModel):
    """
    Configuration of special points.
    """

    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    name: str = Field(..., description='Name of special point.')
    name_simple: Optional[str] = Field(None, alias='name-simple', description='A table-friendly version of the name.')
    description: Optional[str] = Field(None, description='A table-friendly description of the point.')
    ignore: bool = Field(False, description='Option to suppress plotting.')
    ignore_2_d: bool = Field(False, alias='ignore-2D', description='Option to suppress plotting in 2D Plot.')
    derivatives: Optional[List[int]] = None
    found: bool = Field(False, description='Option to mark whether point successfully computed.')
    time: float = Field(-1, description='Time co-ordinate of special point (initially normalised to `[0, 1]`).')
    value: float = Field(-1, description='Value of special point.')
    spec: Optional[SpecialPointsSpec] = Field(
        None, description='Optional specifications for computation of special point.'
    )
    format: Optional[PointFormat] = Field(None, description='Settings for plot marker.')


class Polynomial(BaseModel):
    """
    Settings to fit polynomial interpolation.
    """

    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    pressure: InterpConfigPoly
    volume: Optional[InterpConfigPoly] = None


class InterpConfigTrig(BaseModel):
    """
    Settings used to fit trigonometric interpolations.
    """

    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    solver: Solver = Field(..., description='Settings for the solver.')
    points: Dict[str, str] = Field(..., description='Schema for values to be used in intervals and conditions')
    intervals: List[PairString] = Field(
        ..., description='Defines the spatial domain over which the model is to be defined.', min_length=1
    )
    conditions: List[FitTrigCondition] = Field([], description='Provides restrictions on the frequency.')
    initial: FitTrigIntialisation


class FitExpConfig(BaseModel):
    """
    Settings used to fit exponential curve to parts of model.
    """

    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    solver: Solver1 = Field(..., description='Settings for the solver.')
    points: Dict[str, str] = Field(..., description='Schema for values to be used in intervals and conditions')
    intervals: Optional[List[PairString]] = Field(
        None, description='Defines the spatial domain over which the model is to be defined.', min_length=1
    )
    conditions: List[FitExpCondition] = Field([], description='Provides restrictions on the exponential coefficient.')
    initial: FitExpIntialisation


class SpecialPointsConfigs(BaseModel):
    """
    Configuration of special points.
    """

    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    pressure: Dict[str, SpecialPointsConfig]
    volume: Dict[str, SpecialPointsConfig]
    pv: Dict[str, SpecialPointsConfigPV]


class Trigonometric(BaseModel):
    """
    Settings to fit trigonometric interpolation.
    """

    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    pressure: InterpConfigTrig
    volume: Optional[InterpConfigTrig] = None


class InterpConfig(BaseModel):
    """
    Configuration options for interpolation.
    """

    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    polynomial: Optional[Polynomial] = Field(None, description='Settings to fit polynomial interpolation.')
    trigonometric: Optional[Trigonometric] = Field(None, description='Settings to fit trigonometric interpolation.')


class Settings(BaseModel):
    """
    Primary settings
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    timezone: str
    units: Dict[str, str] = Field(..., description='Standard units for physical conversion.')
    matching: MatchingConfig
    polynomial: PolynomialConfig = Field(
        ..., description='Conditions for initial fitting (polynomial) curves to raw data.'
    )
    interpolation: InterpConfig
    exponential: FitExpConfig = Field(..., description='Settings to fit exponential model.')
    points: SpecialPointsConfigs = Field(..., description='Specifications used to compute special points.')


class AppConfig(BaseModel):
    """
    Data model for all parts of the app configuration.
    """

    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True,
    )
    info: AppInfo
    settings: Settings = Field(..., description='Primary settings')
